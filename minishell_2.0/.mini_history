cat << a
cat << a
cat << a
make
clear
make
./minishell
cat << a
cat << a
cat << a
cat << a 
cat << a
cat << a
cat << a
cat << a
cat << a
cat << a
clear
cat << a << b
clear
cat << a
cat << a
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirection.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/27 19:08:12 by aoo               #+#    #+#             */
/*   Updated: 2025/02/24 17:39:53 by aoo              ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "minishell.h"
intre_input(char *file)
{
intfd_in;
if (file && !access(file, F_OK | R_OK))
{
fd_in = open(file, O_RDONLY);
dprintf(2, "re_input, in : %d\n", fd_in);
if (fd_in > 0)
return (fd_in);
}
write(2, "minishell: ", 12);
write(2, file, ft_strlen(file));
perror(" ");
return (-1);
}
intre_output(char *file, int append)
{
intfd_out;
if (append)
fd_out = open(file, O_WRONLY | O_CREAT | O_APPEND, 0644);
else
fd_out = open(file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
printf("out : %d\n",fd_out);
if (fd_out < 0)
{
write(2, "minishell: ", 12);
write(2, file, ft_strlen(file));
perror(" ");
return (-1);
}
dup2(fd_out, STDOUT_FILENO);
close(fd_out);
return (0);
}
intre_heredoc(char *args, t_list *envp, int status)
{
char*line;
intfd_pipe[2];
char*temp;
if (pipe(fd_pipe) == -1)
return (perror("pipe error"), -1);
signal(SIGINT, handle_sigint_heredoc);
// signal(SIGQUIT, SIG_IGN);
while (1)
{
line = readline("> ");
if(g_sig_interruption)
{
close(fd_pipe[1]);
return (-1);
}
if (!line || ft_strcmp(line, args) == 0)
{
free(line); 
break ;
}
temp = handle_env(line, envp, status);
(write(fd_pipe[1], temp, ft_strlen(temp)), write(fd_pipe[1], "\n", 1));
(free(line), free(temp));
}
return (close(fd_pipe[1]), fd_pipe[0]);
}
// intredirection(char **redirect, t_list *envp, int status)
// {
// inti;
// int here_fd;
// intin_fd;
// int out_fd;
// i = 0;
// here_fd = -1;
// in_fd = -1;
// out_fd = -1;
// while (redirect[i])
// {
// if (!ft_strcmp(redirect[i], "<<") && redirect[++i])
// {
// if (here_fd > 0)
// close (here_fd);
// here_fd = re_heredoc(redirect[i], envp, status);
// }
// i++;
// }
// i = 0;
// while (redirect[i])
// {
// if (!ft_strcmp(redirect[i], "<") && redirect[++i])
// {
// if (in_fd > 0)
// close(in_fd);
// in_fd = re_input(redirect[i]);
// if (in_fd == -1)
// return (-1);
// }
// else if (!ft_strcmp(redirect[i], "<<") && redirect[++i])
// in_fd = here_fd;
// i++;
// }
// i=0;
// while (redirect[i])
// {
// if (!ft_strcmp(redirect[i], ">>") && redirect[++i])
// {
// if (re_output(redirect[i], 1) == -1)
// return (-1);
// }
// else if (!ft_strcmp(redirect[i], ">") && redirect[++i])
// {
// if (re_output(redirect[i], 0) == -1)
// return (-1);
// }
// i++;
// }
// if (in_fd > 0)
// (dup2(in_fd, STDIN_FILENO), close(in_fd));
// return (0);
// }
// Apply redirections using the prepared heredocs
int apply_redirections(t_ast *node)
{
    if (!node || !node->redirect)
        return 0;
    
    char **redirect = node->redirect;
    int i = 0;
    int in_fd = -1;
    int out_fd = -1;
    int heredoc_index = 0;
    
    // First handle input redirections
    while (redirect[i])
    {
        if (!ft_strcmp(redirect[i], "<") && redirect[i+1])
        {
            if (in_fd > 0)
                close(in_fd);
            in_fd = re_input(redirect[i+1]);
            if (in_fd == -1)
                return -1;
        }
        else if (!ft_strcmp(redirect[i], "<<") && redirect[i+1])
        {
            if (in_fd > 0)
                close(in_fd);
            // printf("in_fd %s \n", in_fd);
            // Use the already-prepared heredoc FD
            if (heredoc_index < node->heredoc_count)
{
in_fd = node->heredoc_fds[heredoc_index++];
printf("in_fd %d \n", in_fd);
        }
        i++;
    }
    
    // Then handle output redirections
    i = 0;
    while (redirect[i])
    {
        if (!ft_strcmp(redirect[i], ">") && redirect[i+1])
        {
            if (re_output(redirect[i+1], 0) == -1)
                return -1;
        }
        else if (!ft_strcmp(redirect[i], ">>") && redirect[i+1])
        {
            if (re_output(redirect[i+1], 1) == -1)
                return -1;
        }
        i++;
    }
    // Apply the input redirection if one was set
    if (in_fd > 0)
    {
        dup2(in_fd, STDIN_FILENO);
        close(in_fd);
    }
    
    return 0;
}
cat << a
clear
cat << a
cat << a
cat << a | cat << b cat << c | cat << e
cat << a 
cat << a
cat << a
cat << a << b 
clear
cat << a | cat << b > test
cat test
cat <, a 
echo $?
cat <, a
echo $?
cat <, a
echo $?
cd ..
cat < redirection.c > test
cat test
clear
cat << shit 
cat << a sdsdf sdasdfefsdf
cat << a | cat << b > test
cat test
cat << a
cat << test
cat < a
echo $?
cat <,ad
echo $?
cat << a > test | cat << b > test1
cat test test1
env
export test=ok test1= test2
export
clear
env > test
cat tet
cat test
cat < test
clear
cat > test
cat test
rm -rf test
cat << a < redirection.c > test
cat test
clear
make clean
asdf
clear
sleep 30
clear
make
sleep 2
sleep 30
sleep 3
okaf
sleep 3
sleep 30 | pwd
sleep 40 | pwd
echo $?
pwd | sleep 40 
echo $?
cat < in | sleep 40 
echo $?
sleep 40 
echo $?
cat redirection.c | sleep 40 
cat redirection.c | sleep 40 
echo $?
cat < redirection.c | sleep 40 
echo $?
cat redirection.c | sleep 30 
cat in | sleep 40 
cat  sdf | sleep 40
echo $?
echo a | sleep 40 
echo $?
clear
echo as | sleep 30 
echo $?
echo a | sleep 40 
sleep 40 | echo a
echo $?
sleep 40 | cat a
echo $?
cat a | echo a
echo $?
asdf | sdf
echo a | cat asd
echo $?
cat as d| echo l
cat as d| echo l
echo a | cat asd
echo $?
echo a  | cat asd
clear
make
./m
cat a 
cat a | echo 0
echo a | cat adsf
echo $?
sleep 40 | echo 0
echo $?
cat a | echo a
adfadf
adsf | adsf
clear
cat asd | echo a
<< a
echo a | cat asds
sdfads
a
sleep 40 
sleep 40 
sleep 40 
sleep 40
cat a | echo a 
asdf
cat a 
cat a | echo a
cat a | echo a
cat a | echo a
